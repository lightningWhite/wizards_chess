# Wizards Chess
## Overview
This project provides for voice commanded chess. An XY track system is placed
under a chess board with a magnet on the actuator. There are magnets placed
in each of the chess pieces so the XY track system can move under any piece
and lift the actuator to magnetize to the chess piece and then move to the 
desired location and drop the actuator to leave the piece there. 

The movement of the track system is all by voice commands. There is also a
chess program that runs to manage the logic of chess. This includes not 
allowing the wrong color to be moved.

## Hardware
We used an Eleks Draw for the XY track system. This provided the Arduino nano
and the HR4988 stepper motor controllers. We flashed the Arduino with grbl
for our G-code interpreter. 

We were going to use a Raspberry Pi 3, but ended up having issues getting a 
version of Pocketspinx that could run on ROS Indigo on the version of Linux
we were running.

We also used a USB microphone for the input. 

##Software
We used ROS Indigo for this project. We installed Pocketsphinx for the voice
recognition. Instructions for installing pocketsphinx can be found at 
wiki.ros.org/pocketsphinx. 

Pocketsphinx required that we generated a .corpus, language model, and a 
dictionary. Instructions for generating these can be found at the above 
mentioned website. 

We also wrote a program called corpusGenerator that created combinations of 
voice commands that would commonly be used when playing chess. These would be
things like "a1 to a2" and so forth. We only generated commands from each cell, 
one cell in every straight and diagonal direction. We didn't generate moves
of multiples cells, as this would be quite a large file. After generating
the corpus, we ran it through the online dictionary and learning model
generator. It turned out that the corpus probably didn't need to be quite
as extensive as we made it.

We wrote a chess program that maintained the placement of each chess piece and
did the logic checking of the moves. There is a basic visual chess board
that is shown as part of this program.

Here is a list of the main files for the project and what they do:
### chess.cpp 
The raw chess logic program. We put this into the wizards_chess_subscriber.cpp ros node eventually.
### chess_mapping.cpp
This was the start for what was put into the track_controller_node.cpp ros node.
### corpusGenerator.cpp
This generates a corpus that can be sent to the online dictionary and learning model generator. To run it, do 'g++ corpusGenerator.cpp' to compile it and then run './a.out > wizards_chess.corpus'
### grbl.gcode
This is just the file that is generated by the track_controller_node.cpp. It contains the G-code needed to move the server motors to a given chess board cell.
### recognizer.py
This is the node that is run for getting the voice input and publishing the string message
### simple_stream.py
This script is used to stream the grbl.gcode file to the Arduino
### track_controller_node.cpp
This node maps chess board cells as received from the wizards_chess_subscriber.cpp 
node to G-code commands specific to the chess board we were using. This chess board 
was approximately 9 1/4 inches square. Each cell was approximately 1 3/16 inches square. 
This will only work with the Eleks Maker.
### wizards_chess.corpus
This is the file containing the common phrases that will be used.
### wizards_chess.dic
The dictionary for pocketsphinx.
### wizards_chess.lm
The learning model for pocketsphinx.
### wizards_chess_subscriber.cpp
This ROS node takes the output from the recognizer.py node as a string 
and then checks the validity of the command. Not all of the chess logic is implemented yet.
It will display a chess board in the terminal and the location of all the pieces.

## Running the Project
Do the following to start the project:
1. In one terminal, type roslaunch wizards_chess wizards_chess.launch This starts the recognizer. 
2. In another terminal, navigate to ~/catkin_ws/devel/lib/wizards_chess and start the wizards_chess_subscriber executable
   This is done by typing './wizards_chess_subscriber'
3. In another terminal, navigate to the same place as in step 2 and type ./track_controller_node

At this point, you should be able to give voice commands to the microphone and see the track move from the source cell 
to the destination cell. The voice commands must be in the following form "source to destination." I.e. "C4 to C5" for 
it to work properly. 



## Problems
- If using Brother Grimmett's Eleks Maker, one of the stepper motor cabels had
  two wires crossed. This caused the motor to be jerky and uncontrollable.
  We removed the cable and had to use jumper wires to go from the motor to 
  the Arduino.
- We wanted to get Pocketsphinx installed on the Raspberry Pi for it to all
  be run off of that, but had issues getting a Linux distro and ROS version
  that was compatible.
- We still need to add code to lift the actuator for the magnet to attract to the
  chess piece and drop to leave the chess piece there. There is a G-code command
  that made the actuator turn, but we didn't get it working properly. 
  The following cheat sheet may be helpful: www.makeit3d.com/wp-content/uploads/RepRapGcodeCheatSheet.pdf
  It may have been one of the z axis commands...

## Future Additions
- It would be nice to have an electromagnet instead of the actuator. 
- More logic needs to be implemented in the chess program for invalid moves per piece.
- Some sort of algorithm needs to be developed in order to move the knight over pieces. This 
  may include moving pieces out of the way, moving the Knight, and then putting the pieces back. Or
  It might be done by weaving the knight between pieces.

